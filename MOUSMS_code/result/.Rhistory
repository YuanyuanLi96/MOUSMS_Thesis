rep_3(case,rho, family, sigmasq_t, B,
alpha,delta, n, p, penalty,tune,screen,iter)
plot(lasso_init)
simu_3.PL(3,"gaussian", B,n,p, sigmasq_t,
alpha, K, cores, rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
rep_3(case,rho, family, sigmasq_t, B,
alpha,delta, n, p, penalty,tune,screen,iter)
fixed.b=True
fixed.b=TRUE
z = abs(rnorm(non.zeros)); signs = rbinom(non.zeros,1,0.4)
zero.entries = which(signs==0); signs[zero.entries] = -1
f1 = 5*log(n)/n^(1/2); f2 = z; b = (f1 + f2)*signs
b
b=rep(1, non.zeros)
b=c(1,-1,-1)
plot(lasso_init)
n+1
n
p
p=20
n=40
?SIS
simu_3.PL(3,"gaussian", B,n,p, sigmasq_t,
alpha, K, cores, rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
rep_3(case,rho, family, sigmasq_t, B,
alpha,delta, n, p, penalty,tune,screen,iter)
plot(lasso_init)
var.order
betas
eoinfo$CE
#simu_3.PL(1,"gaussian", B,n,p,sigmasq_t,
# alpha, K, cores,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
#simu_3.PL(2,"gaussian", B,n,p, sigmasq_t,
#alpha, K, cores,rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
simu_3.PL(3,"gaussian", B,n,p, sigmasq_t,
alpha, K, cores, rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
rep_3(case,rho, family, sigmasq_t, B,
alpha,delta, n, p, penalty,tune,screen,iter)
hat_M$var.order
plot(lasso_init)
n=60
#simu_3.PL(1,"gaussian", B,n,p,sigmasq_t,
# alpha, K, cores,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
#simu_3.PL(2,"gaussian", B,n,p, sigmasq_t,
#alpha, K, cores,rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
simu_3.PL(3,"gaussian", B,n,p, sigmasq_t,
alpha, K, cores, rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
rep_3(case,rho, family, sigmasq_t, B,
alpha,delta, n, p, penalty,tune,screen,iter)
plot(lasso_init)
n=50
p
p=30
#simu_3.PL(1,"gaussian", B,n,p,sigmasq_t,
# alpha, K, cores,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
#simu_3.PL(2,"gaussian", B,n,p, sigmasq_t,
#alpha, K, cores,rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
simu_3.PL(3,"gaussian", B,n,p, sigmasq_t,
alpha, K, cores, rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
#simu_3.PL(1,"gaussian", B,n,p,sigmasq_t,
# alpha, K, cores,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
#simu_3.PL(2,"gaussian", B,n,p, sigmasq_t,
#alpha, K, cores,rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
simu_3.PL(3,"gaussian", B,n,p, sigmasq_t,
alpha, K, cores, rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
rep_3(case,rho, family, sigmasq_t, B,
alpha,delta, n, p, penalty,tune,screen,iter)
p
plot(lasso_init)
n=50
p=20
#simu_3.PL(1,"gaussian", B,n,p,sigmasq_t,
# alpha, K, cores,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
#simu_3.PL(2,"gaussian", B,n,p, sigmasq_t,
#alpha, K, cores,rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
simu_3.PL(3,"gaussian", B,n,p, sigmasq_t,
alpha, K, cores, rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
rep_3(case,rho, family, sigmasq_t, B,
alpha,delta, n, p, penalty,tune,screen,iter)
plot(lasso_init)
#simu_3.PL(1,"gaussian", B,n,p,sigmasq_t,
# alpha, K, cores,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
#simu_3.PL(2,"gaussian", B,n,p, sigmasq_t,
#alpha, K, cores,rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
simu_3.PL(3,"gaussian", B,n,p, sigmasq_t,
alpha, K, cores, rho=0.5,penalty="adlasso", tune=tune,screen = T,iter=iter,r.names=r.names)
p
p=30
rep_3(case,rho, family, sigmasq_t, B,
alpha,delta, n, p, penalty,tune,screen,iter)
plot(lasso_init)
plot(lasso_init)
summary(lasso_init)
var.order
lasso_init <- cv.glmnet(x,y, family=family,nfolds = 10)
plot(lasso_init )
hat_M$beta
library(BMA)
library(rlist)
library(MASS)
library(parallel)
library(ggplot2)
library(plot.matrix)
library(glmnet)
##This is the method we proposed in our paper
MAC =function(models, data, B, alpha, delta,family){
X = data$x
n = nrow(X)
#select model using original data
hat_M = BIC_selection(models, data, n)#a list including \hat{M}, \hat{\psi} and rank
hat_M_index = hat_M$index
rank_M = hat_M$rank
##bootstrap procedure
boot_index = rep(0, B)
rank_boot = matrix(0, nrow = B, ncol = length(models))
for (b in 1:B){
#generate data under hat_M
y_b <- Generate.Y(hat_M$predy,hat_M$sigmasq_select,n, family)
dataF_b=list(y=y_b, x=X)
#select model using bootstrap data
hat_M_boot = BIC_selection(models, dataF_b, n)#a list including \hat{M}, \hat{\psi} and rank
boot_index[b] = hat_M_boot$index
rank_boot[b,] = hat_M_boot$rank
}
result =list()
result$hat_M = hat_M_index
##confidence sets
prob_boot = apply(rank_boot, 2, function(x)sum(x == hat_M_index)/B)
sum_prob = sapply(1:length(prob_boot), function(x)sum(prob_boot[1:x]))
k = sapply(alpha, function(x)which(sum_prob-1+x>=-eps)[1])
result$order= rank_M
result$probs_inorder= prob_boot
result$betals= hat_M$betals
result$sigmasq=hat_M$sigmasq
result$con_sets = lapply(k, function(x)rank_M[1:x])
result$length_con = k
##prob of \hat{M}_b = \hat{M}
result$hat_prob = sum(boot_index == hat_M_index)/B
result$hat_logP = log(1 - ifelse(result$hat_prob<1, result$hat_prob, 1 - delta))
return(result)
}
bma = function(data, fix=NULL,alpha){
Y= data$y
X= data$x
if (length(fix) >0){
X=as.matrix(X[,-fix])
}
post = list()
fit=bic.glm(X,Y,glm.family = gaussian(),
occam.window=F, OR.fix=1000)
mod.probs=fit$postprob
mm = apply(fit$which,1, function(x)c(which(x==T), fix))
names(mm) =as.character(1:length(mm))
sum_prob = sapply(1:length(mod.probs), function(x)sum(mod.probs[1:x]))
k = sapply(alpha,function(x)which(sum_prob-1+x>=-eps)[1])
result=list()
result$probs_inorder= mod.probs
result$con_sets = lapply(k, function(x)mm[1:x])#return a list of sublists(models)
result$length_con = k
result$models=mm
result$betals=apply(fit$mle,1,function(x)x[x!=0])
return(result)
}
ar1_cor <- function(n, rho) {
exponent <- abs(matrix(1:n - 1, nrow = n, ncol = n, byrow = TRUE) -
(1:n - 1))
return(rho^exponent)
}
Generate.X <- function(case,n,p, rho, fixed.b=T){
non.zeros = 3
b=rep(1, non.zeros)
if(fixed.b==F){
z = abs(rnorm(non.zeros)); signs = rbinom(non.zeros,1,0.4)
zero.entries = which(signs==0); signs[zero.entries] = -1
f1 = 5*log(n)/n^(1/2); f2 = z; b = (f1 + f2)*signs
}
true.beta = rep(0,p)
true.beta[1:non.zeros] = b
if(case==0){
non.zeros = 2
true.beta = c(1,1,0)
x1 = rbinom(n, 1, 0.5)
x2 = rnorm(n,0,1)
x= cbind(x1 = x1, x2=x2, x2sq = x2^2)
}
if(case == 1){#independent features
x = matrix(rnorm(n*p, mean=0, sd=1), n, p)
}
if(case==2){#exponential decay correlation
Sigma=ar1_cor(p,rho)
x=mvrnorm(n,mu=rep(0,p), Sigma = Sigma)
}
if(case == 3){#undecay correlation
corrmat = diag(rep(1-rho, p)) + matrix(rho, p, p)
cholmat = chol(corrmat)
x = matrix(rnorm(n*p, 0, 1), n, p)
x = x%*%cholmat
}
else if(case == 4){#nonlinear relation
true.beta = rep(0,p)
true.beta[1:non.zeros] = 1
x=matrix(rnorm(n*p),n,p)
x[,2]=-1/3*x[,1]^3+rnorm(n)
}
S = 1:non.zeros
#Check irrespresentable condition
C=1/n*t(x)%*%x
C11=C[S,S]
C21=C[-S,S]
s=sign(true.beta[S])
IR=all(abs(C21 %*% solve(C11) %*% s) -1<eps)
data=list(x=x,n=n,p=p,s=non.zeros,var_t=S,true.beta=true.beta,IR=IR )
return(data)
}
Generate.Y <- function(predy, sigmasq, n, family) {
if (family %in% c("gaussian","non-parametric")){
Y = predy + rnorm(n,0, sd = sqrt(sigmasq))
}
if (family=="binomial"){
prob=1/(1+exp(-predy))
Y = rbinom(n=n,size=1, prob=prob)
}
return(Y)
}
#every sublist should have same structure
flatten = function(alist,K){
newlist=alist[[1]]
if (K >1){
for(j in 2:K){
newlist=Map(rbind,newlist,alist[[j]])
}
}
return(newlist)
}
matchfunc =function(a,b){
c = all(a%in%b) & all(b%in% a)
return(as.numeric(c))
}
#predictors is a vector,like 1,...,p
Models.generate = function(predictors){
models = lapply(0:length(predictors), function(x)combn(predictors,x,simplify =F))
models = list.flatten(models)
names(models) =as.character(1:length(models))
return(models)
}
#Calculate and rank the BIC values of all models
BIC_selection = function(models,data,n){
m = length(models)
score = rep(0,m)
sigmasq = rep(0,m)
betals = list()
Y=data$y
X=data$x
for (i in 1:m){
len = length(models[[i]])
if (len==0){
fit=lm(Y~1)
}else{
Xi = X[,models[[i]]]
fit=lm(Y~Xi)
}
sigmasq[i] = sum((fit$residuals - mean(fit$residuals))^2)/n
betals[[i]]=fit$coefficients
df = sum(betals[[i]]!=0)+1
score[i] = n * log(sigmasq[i]) + log(n) * df
}
result = list()
result$rank = order(score)
result$betals= betals
selected = result$rank[1]
result$index = selected
result$hat_M = models[[selected]]
result$predy=cbind(1,X[,result$hat_M]) %*% betals[[selected]]
result$sigmasq_select=sigmasq[selected]
result$sigmasq=sigmasq
return(result)
}
combined_pred=function(models, betals, weights_inorder,order, X){
ypred_inorder = sapply(order, function(x)cbind(1,X[,models[[x]]]) %*% betals[[x]])
combined_pred=ypred_inorder %*% weights_inorder
return(combined_pred)
}
#beta is a vector of all fixed effects
rep_3=function(case,rho,family="gaussian",sigmasq_t, B, alpha, n, p){
train=Generate.X(case,n,p,rho)
X= train$x
predictors=1:ncol(X)
models=Models.generate(predictors)
var_t= train$var_t
predy=train$x %*% train$true.beta
#generate data under Mopt
Y <- Generate.Y(predy, sigmasq_t,n, family)
train$y=Y
test=Generate.X(case,n,p,rho)
test_x= test$x
true_mean=test_x %*% test$true.beta
test_y<- Generate.Y(true_mean, sigmasq_t,n, family)
#test_data=list(test_y,test_x)
###all models
##MAC:bootstrap weights
mac.result = MAC(models, train,B, alpha,0.001,family)
weights=mac.result$probs_inorder
predy_MAC= combined_pred(models, mac.result$betals, weights, mac.result$order,test_x)
MSPE_MAC= mean((test_y-predy)^2)
##BMA: posterior weights
BMA = bma(train, fix=NULL,alpha)
weights_bma=BMA$probs_inorder
predy_bma= combined_pred(BMA$models, BMA$betals, weights_bma,
1:length(BMA$models),test_x)
MSPE_BMA= mean((test_y-predy_bma)^2)
#Equal weights
m=length(models)
weights_EW=rep(1/m,m)
predy_EW= combined_pred(models, mac.result$betals, weights_EW, mac.result$order,test_x)
MSPE_EW= mean((test_y-predy_EW)^2)
#IMSE weights
m=length(models)
MSE_mse=mac.result$sigmasq
zero_index=which(MSE_mse<eps)
MSE_mse[zero_index]=eps
IMSE_mse=1/MSE_mse
weights_IMSE=IMSE_mse/sum(IMSE_mse)
predy_IMSE= combined_pred(models, mac.result$betals, weights_IMSE, 1:m,test_x)
MSPE_IMSE= mean((test_y-predy_IMSE)^2)
##prediction on single selected model
#MAC single selected model
weights_mac_SS=c(1, rep(0,m-1))
predy_mac_SS=combined_pred(models, mac.result$betals, weights_mac_SS, mac.result$order,test_x)
MSPE_mac_SS = mean((test_y-predy_mac_SS)^2)
result=c(MSPE_MAC, MSPE_BMA, MSPE_EW, MSPE_IMSE, MSPE_mac_SS)
return(result)
}
simu_1= function(case,family="gaussian", B,n,p,sigmasq_t, alpha, K,cores, rho){
Boot = mclapply(1:K, function(x)rep_3(case,rho, family,sigmasq_t, B, alpha, n, p),mc.cores=cores)
newlist = flatten(Boot,K)
result=matrix(sapply(newlist,mean),5,1)
return(result)
}
case=3
rho=0.8
n=100
K=100
family="gaussian"
p=10
sigmasq_t=2
alpha=0.001
B=500
cores=6
debug(simu_1)
simu=simu_1(case,family="gaussian", B,n,p,sigmasq_t, alpha, K,cores, rho)
rep_3(case,rho, family,sigmasq_t, B, alpha, n, p)
debug(Generate.X)
debug(Generate.X)
rep_3(case,rho, family,sigmasq_t, B, alpha, n, p)
case=3
rho=0.8
n=100
K=100
family="gaussian"
p=10
sigmasq_t=2
alpha=0.001
B=500
cores=6
simu=simu_1(case,family="gaussian", B,n,p,sigmasq_t, alpha, K,cores, rho)
rep_3(case,rho, family,sigmasq_t, B, alpha, n, p)
simu=simu_1(case,family="gaussian", B,n,p,sigmasq_t, alpha, K,cores, rho)
rep_3(case,rho, family,sigmasq_t, B, alpha, n, p)
eps=1e-6
eps
eps=1e-6
eps=1e-6
simu=simu_1(case,family="gaussian", B,n,p,sigmasq_t, alpha, K,cores, rho)
simu=simu_1(case,family="gaussian", B,n,p,sigmasq_t, alpha, K,cores, rho)
simu=simu_1(case,family="gaussian", B,n,p,sigmasq_t, alpha, K,cores, rho)
rep_3(case,rho, family,sigmasq_t, B, alpha, n, p)
rep_3(case,rho, family,sigmasq_t, B, alpha, n, p)
#beta is a vector of all fixed effects
rep_3=function(case,rho,family="gaussian",sigmasq_t, B, alpha, n, p){
train=Generate.X(case,n,p,rho)
X= train$x
predictors=1:ncol(X)
models=Models.generate(predictors)
var_t= train$var_t
predy=train$x %*% train$true.beta
#generate data under Mopt
Y <- Generate.Y(predy, sigmasq_t,n, family)
train$y=Y
test=Generate.X(case,n,p,rho)
test_x= test$x
true_mean=test_x %*% test$true.beta
test_y<- Generate.Y(true_mean, sigmasq_t,n, family)
#test_data=list(test_y,test_x)
###all models
##MAC:bootstrap weights
mac.result = MAC(models, train,B, alpha,0.001,family)
weights=mac.result$probs_inorder
predy_MAC= combined_pred(models, mac.result$betals, weights, mac.result$order,test_x)
MSPE_MAC= mean((test_y-predy)^2)
##BMA: posterior weights
BMA = bma(train, fix=NULL,alpha)
weights_bma=BMA$probs_inorder
predy_bma= combined_pred(BMA$models, BMA$betals, weights_bma,
1:length(BMA$models),test_x)
MSPE_BMA= mean((test_y-predy_bma)^2)
#Equal weights
m=length(models)
weights_EW=rep(1/m,m)
predy_EW= combined_pred(models, mac.result$betals, weights_EW, mac.result$order,test_x)
MSPE_EW= mean((test_y-predy_EW)^2)
#IMSE weights
m=length(models)
MSE_mse=mac.result$sigmasq
zero_index=which(MSE_mse<eps)
MSE_mse[zero_index]=eps
IMSE_mse=1/MSE_mse
weights_IMSE=IMSE_mse/sum(IMSE_mse)
predy_IMSE= combined_pred(models, mac.result$betals, weights_IMSE, 1:m,test_x)
MSPE_IMSE= mean((test_y-predy_IMSE)^2)
##prediction on single selected model
#MAC single selected model
weights_mac_SS=c(1, rep(0,m-1))
predy_mac_SS=combined_pred(models, mac.result$betals, weights_mac_SS, mac.result$order,test_x)
MSPE_mac_SS = mean((test_y-predy_mac_SS)^2)
result=c(MSPE_MAC, MSPE_BMA, MSPE_EW, MSPE_IMSE, MSPE_mac_SS)
return(result)
}
simu=simu_1(case,family="gaussian", B,n,p,sigmasq_t, alpha, K,cores, rho)
debug(rep_3)
rep_3(case,rho, family,sigmasq_t, B, alpha, n, p)
undebug(Generate.X)
mac.result$probs_inorder
p
180000/12
2+
3
2+3
2+3
2+3
rnorm(100)
a=2
a+b
hist(rnorm(100))
?hist
2+4
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=6, fig.height=4)
31/4*(37-25)
3^2
sqrt(36)
log(4)
cos(6)
x = 5
x <- 5
5 -> x
x+3
x^2
sqrt(x)
y = x^2
x = 10
x = x+1
# Create a vector
c(1,3,2,4)
# Save the vector as 'x'
x = c(1,3,2,4)
# R applies functions to every element of a vector
x - 10
x^2
# Create a vector
c(1,3,2,4)
# Save the vector as 'x'
x = c(1,3,2,4)
# R applies functions to every element of a vector
x - 10
x^2
# Create a vector
c(1,3,2,4)
# Save the vector as 'x'
x = c(1,3,2,4)
# R applies functions to every element of a vector
x - 10
x^2
data1 = read.table("~/Desktop/datasets/airfreight+breakage.txt")
View(data1)
View(data1)
`airfreight+breakage` <- read.table("~/OneDrive - University of California, Davis/books/108s21/UCDSTA108-master/datasets/airfreight+breakage.txt", quote="\"", comment.char="")
View(`airfreight+breakage`)
head(data1)#Display the first six rows
data1[1:3,]#Display the first six rows by row index
Y = data1[,1] # Extract variables from dataset
X = data1[,2]
data1[3,2]#Display the value is row 3 and column 2
data1[3,2]#Display the value is row 3 and column 2
# histograms
hist(Y)
# boxplots
boxplot(Y, main = 'Boxplot of Y')
# scatterplots
plot(X, Y, xlab = 'X', ylab = 'Y', main = 'Plot of Y versus X')
binomial_cs <- read.csv("~/OneDrive - University of California, Davis/paper/dissertation/nmcs/MOUSMS_code/result/binomial_cs.csv", header=FALSE)
View(binomial_cs)
`airfreight+breakage` <- read.table("~/OneDrive - University of California, Davis/books/108s21/UCDSTA108-master/datasets/airfreight+breakage.txt", quote="\"", comment.char="")
View(`airfreight+breakage`)
setwd("~/OneDrive - University of California, Davis/books/108s21/UCDSTA108-master/datasets")#set working directory to "datasets" folder
data1 = read.table("airfreight+breakage.txt")#read the data set in the
setwd("~/OneDrive - University of California, Davis/books/108s21/UCDSTA108-master/datasets")#set working directory to "datasets" folder
data1 = read.table("airfreight+breakage.txt")#read the data set in the
data1 = read.table("~/OneDrive - University of California, Davis/books/108s21/UCDSTA108-master/datasets/airfreight+breakage.txt")
9+1
6+2
6+2
rnorm(20)
